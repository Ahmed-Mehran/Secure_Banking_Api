### WHY DO WE NEED THIS INTERCEPTOR FILE

# When your tutor says “we are going to define an interceptor handler for capturing all logs from Django and other libraries,” it means that we want all log messages, not just the ones we write using 
# logger.info() or logger.error(), but also those automatically generated by Django’s internal system (like startup messages, database queries, errors, warnings, etc.) and third-party
# libraries (like requests, celery, or boto3) — to pass through Loguru’s logging system. Normally, these built-in or library logs use Python’s default logging module, not Loguru. So if we
# don’t do anything, they won’t appear in our Loguru logs.
# That’s where the interceptor handler comes in. This handler acts like a “bridge” between Django’s default logging system and Loguru. It intercepts (or catches) every log message that Django 
# or any library tries to log using the standard logging module, and then forwards those logs into Loguru so that everything — your own loguru logs, Django logs, and library logs — are handled in one
# consistent way and stored in your defined log files.
#In short, we need the interceptor handler so that Loguru becomes the single point of control for all logs in the project. Without it, some logs (like Django errors or warnings from libraries) would 
# go unnoticed or appear only in the console, not in your structured Loguru log files.




from loguru import logger
import logging ## importing the built in loggin module(not by loguru)


# So, if one part of your code or a third-party library uses the standard logging module, and another uses Loguru, their logs will not automatically appear together.
# This code solves that problem. It defines a special handler (called InterceptHandler) that catches every message sent to the standard logging system and redirects it to Loguru’s logger.
# In simpler words: It acts like a “bridge” that takes logs from Python’s built-in logging and passes them to Loguru’s logger, so all your logs end up in one consistent format and output.

class InterceptHandler(logging.Handler):
    
    def emit(self, record):
        
        try:
            
            level = logger.level(record.levelname).name
            
        except:
            
            level = record.levelno
            
        frame, depth = logging.currentframe(), 2
        
        while frame.f_code.co_filename == logging.__file__:
            
            frame = frame.f_back
            depth += 1
            
        logger.opt(depth=depth, exception=record.exc_info).log(level, record.getMessage())
        
        
            
            