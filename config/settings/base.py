"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
from dotenv import load_dotenv
from os import getenv, path
from loguru import logger
from datetime import timedelta




# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve(strict=True).parent.parent.parent ## Actual path of the Base/root directory

APPS_DIR = BASE_DIR / "core_apps" ## Here APPS_DIR points to the path/folder containing the main apps

local_env_file = BASE_DIR / ".envs" / ".env.local" ## we can write this line like below as well but this is more preferred
##local_env_file = path.join(BASE_DIR, ".envs", ".env.local")

if path.isfile(local_env_file):  ## This checks whether the file actually exists before trying to load it. It avoids attempting to load a non-existent file and makes the subsequent load_dotenv a guarded, explicit action.
    
    load_dotenv(local_env_file) ## This reads the key/value pairs inside the specified file and sets them into the process environment so subsequent calls to getenv("NAME") will return those values. This is the line that
                                # actually imports your local configuration into the running process.


#### -- The below are in local.py
#### --Why were these removed from base.py?
## The base.py file is meant to hold only the settings that are common across all environments (local, staging, production). Things like INSTALLED_APPS, MIDDLEWARE, or TEMPLATES usually stay the same 
# whether you’re running Django on your laptop or on a server.
# But the three settings you showed — SECRET_KEY, DEBUG, and ALLOWED_HOSTS — are environment-specific. They should change depending on where Django is running. If you leave them in base.py, then both 
# your local and production environments would share the same values, which is dangerous and not flexible. That’s why they were removed from base.py and pushed into the environment-specific settings files.

# # Quick-start development settings - unsuitable for production
# # See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# # SECURITY WARNING: keep the secret key used in production secret!
# SECRET_KEY = 'django-insecure-d5wn!+*s%=qp16^if17h$#f1g+v140dv-#l@y3ny+^i)zr%x-('

# # SECURITY WARNING: don't run with debug turned on in production!
# DEBUG = True

# ALLOWED_HOSTS = []



# Application definition

DJANGO_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    "django.contrib.sites",
    "django.contrib.humanize",
]

THIRD_PARTY_APPS = [
    "rest_framework",
    "django_countries",
    "phonenumber_field",
    "drf_spectacular",
    "djoser",
    "cloudinary",
    "django_filters",
    "djcelery_email",
    "django_celery_beat"
]

LOCAL_APPS = ["core_apps.user_auth", "core_apps.common", "core_apps.user_profile"]

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS


MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [ ## The TEMPLATES setting in Django tells the framework where and how to find HTML templates for rendering your views.
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [str(APPS_DIR / "templates")],  ## DIRS → a list of directories where Django will look for templates outside of apps. If this is kept empty it will only look for templates in the actual Django Apps(created by startapp command)
        'APP_DIRS': True,  ## if True, Django will also look for a templates/ folder inside each app listed in INSTALLED_APPS.
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": getenv("POSTGRES_DB"),
        "USER": getenv("POSTGRES_USER"),
        "PASSWORD": getenv("POSTGRES_PASSWORD"),
        "HOST": getenv("POSTGRES_HOST"),
        "PORT": getenv("POSTGRES_PORT"),
        
    }
}

PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]



# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

SITE_ID = 1

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = str(BASE_DIR / "staticfiles")

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
AUTH_USER_MODEL = "user_auth.User"   ## This basically stores or tells django the location of custom user model that we have created 



### -- Now we will work with DRF spectacular, DRF Spectacular is an addon/library for DRF that automatically generates API documentation (OpenAPI / Swagger schema) for APIs built using DRF
#      We have to configure it under the REST_FRAMEWORK{} settings here
REST_FRAMEWORK = {
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
    }

## After the above, we have to add a spectacular setting for our base.py. The above and below is to done by default whenever we want to work with DRF spectacular, you can read about DRF spectaculr more from drf-spectacular documentation
SPECTACULAR_SETTINGS = {
    "TITLE": "NextGen Bank API",
    "DESCRIPTION": "An API built for a banking system",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
    "LICENSE": {
        "name": "MIT License",
        "url": "https://opensource.org/license/mit",
    },
}


LOGGING_CONFIG = None 
# By default, Django automatically sets up its own logging configuration when the project starts. It uses a setting called LOGGING inside your settings.py file and applies it through:

# LOGGING_CONFIG = 'django.utils.log.configure_logging'

# That means Django automatically configures and manages all loggers, handlers, and formatters on startup. By default, Django does not explicitly show this line in your settings.py — but 
# it’s applied internally by Django itself when the project starts.
# When you write this line i.e LOGGING_CONFIG = None, you’re disabling Django’s automatic logging configuration so that you can control it fully using your own tool — here, loguru.
# We write this LOGGING_CONFIG = None because when we use loguru, it provides its own powerful and flexible logging system, completely independent from Django’s built-in one.
# If we let Django also apply its logging configuration, it can clash or duplicate logs, causing messy outputs or multiple handlers writing the same message.
# HERE WE ARE JUST DISABLING THE DJANGO LOGGING CONFIG, NOT THE LOGS ITSELF FROM DJANGO OR OTHER LIBRARIES, WHICH WILL BE ANYHOW GENERATED


LOGURU_LOGGING = {
    
    "handlers" : [    ## Handlers are responsible for dispatching log messages to their appropriate destinations such as to console or a specific file or email etc
                       # You can have multiple handlers for different log destinations.
        
        {
            "sink": BASE_DIR / "logs/debug.log",  ## Sink specifies a destination for each record produced by the logger, here basically we refer refer the location where
                                                  ## we want our log files to be. This log file will be responsible for displaying log records with different log levels
                                                   # Here, it means all log messages handled by this configuration will be written to the file located at BASE_DIR/logs/debug.log
                                                  
                                                 
            "level": "DEBUG",  ## By this we mean that we are going to store log message of level debug and the levels above debug(info, success and warning)
            
            "filter": lambda record: record["level"].no <= logger.level("WARNING").no,  ## this filter function checks if the log records is less than or equal to warning level. This means
                                                                                     # that this log file will include the debug, info and warning logs but exclude error and critical logs
                                                                                     # The filter function is called for each log record.It checks if the log level number (record["level"].no)
                                                                                     # is less than or equal to the numeric value of WARNING.
                                                                                     
            "format": "{time:YYYY-MM-DD HH:mm:ss.SSS} | {level: <8} | {name}:{function}:{line} - {message}",  ## This format basically represents the format we want for our log messages i.e this
                                                                                                              # this is the format they would be stored in the log file. The | separates the different
                                                                                                              # part of the format message. This is just a separator to make the log line easier to read
                                                                                                              # The {level} placeholder is used to include the log level. Example: INFO or ERROR
                                                                                                              # The <8 species that the min width of the log level field 
                                                                                                              # The {name} is the module name (the Python file) where the log message came from.
                                                                                                              # Example: if the log is from views.py, it’ll show views.
                                                                                                              # The {function} represents the function name inside the file where the log was written.
                                                                                                              # Example: if you logged inside def get_user():, it’ll show get_user.
                                                                                                              # The {line} represnts line number in the code where the log statement is written.
                                                                                                              # Example: views.py:get_user:42 → line 42 inside get_user() in views.py
                                                                                                              # - is just another separator before the actual message for readability.
                                                                                                              # The {message} represents the actual log message you wrote in your code
                                                                                                              # "2025-10-21 18:45:23.124 | INFO     | views:get_user:42 - User successfully logged in"
                                                                                                              
            "rotation": "10MB",
            
            "retention": "30 days",
            
            "compression": "zip"                                                                                                                                        
        },
        
        {
            "sink": BASE_DIR / "logs/error.log",  
                                                 
            "level": "ERROR", 
            
            "filter": lambda record: record["level"].no >= logger.level("ERROR").no, ## capturing error and critical logs
                                                                                     
            "format": "{time:YYYY-MM-DD HH:mm:ss.SSS} | {level: <8} | {name}:{function}:{line} - {message}", 
            
            "rotation": "10MB",
            
            "retention": "30 days",
            
            "compression": "zip",
            
            "backtrace": True,
            
            "diagnose": True                                                                                                                                       
        }
        
        
    ]
}

logger.configure(**LOGURU_LOGGING)


LOGGING = {
    
    "version": 1,
    
    "disable_existing_loggers": False,
    
    "handlers": {"loguru" :{"class": "interceptor.InterceptHandler"}},
    
    "root": {"handlers": ["loguru"], "level": "DEBUG"}
}




